<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Working with KCT CBCT 3 Python implementation of circular CT trajectory | KCT framework</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://kulvait.github.io/KCT_doc/posts/working-with-kct-cbct-3-python-implementation-of-circular-ct-trajectory.html">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]--><meta name="author" content="Vojtěch Kulvait">
<link rel="prev" href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html" title="Working with KCT CBCT 2 Projective geometry and camera matrices to describe CT geometry" type="text/html">
<link rel="next" href="working-with-kct-cbct-4-first-cone-beam-ct-projection.html" title="Working with KCT CBCT 4 First cone beam CT projection" type="text/html">
<meta property="og:site_name" content="KCT framework">
<meta property="og:title" content="Working with KCT CBCT 3 Python implementation of circular CT trajector">
<meta property="og:url" content="https://kulvait.github.io/KCT_doc/posts/working-with-kct-cbct-3-python-implementation-of-circular-ct-trajectory.html">
<meta property="og:description" content="In the last post we build the mathematical foundation how to construct camera matrices for FDCT setup. Now we use this knowledge to create DEN file with a circular geometry and show how to work with i">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2021-09-15T12:05:50+02:00">
<meta property="article:tag" content="using_kct_blog">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../">

            <span id="blog-title">KCT framework</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../categories/using_kct_blog.html" class="nav-link">Using KCT blog</a>
                </li>
<li class="nav-item">
<a href="../posts" class="nav-link">Blog posts</a>
                </li>
<li class="nav-item">
<a href="../archive.html" class="nav-link">Blog Archive</a>
                </li>
<li class="nav-item">
<a href="../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right">
<li class="nav-item">
    <a href="working-with-kct-cbct-3-python-implementation-of-circular-ct-trajectory.md" id="sourcelink" class="nav-link">Source</a>
    </li>


                
            </ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="#" class="u-url">Working with KCT CBCT 3 Python implementation of circular CT trajectory</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Vojtěch Kulvait
            </span></p>
            <p class="dateline">
            <a href="#" rel="bookmark">
            <time class="published dt-published" datetime="2021-09-15T12:05:50+02:00" itemprop="datePublished" title="2021-09-15 12:05">2021-09-15 12:05</time></a>
            </p>
            
        <p class="sourceline"><a href="working-with-kct-cbct-3-python-implementation-of-circular-ct-trajectory.md" class="sourcelink">Source</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>In the last post we build the mathematical foundation how to construct camera matrices for FDCT setup. Now we use this knowledge to create DEN file with a circular geometry and show how to work with it in the KCT package.</p>
<h3>System setup</h3>
<p>We have yet mastered the theory so let's produce the set of camera matrices for given trajectory.
I have put a script that implements what has been said <a href="https://github.com/kulvait/KCT_scripts/blob/master/createCameraMatricesForCircularScanTrajectory.py">to github</a>.
Version of <a href="https://github.com/kulvait/KCT_denpy">denpy</a> package must be at least 1.1.2 to have function for storing double DEN <code>storeNdarrayAsDoubleDEN</code>.</p>
<p>For this demonstration to run on your computer you first need to install <code>denpy</code> package and clone <a href="https://github.com/kulvait/KCT_scripts">DEN scripts</a> package. Let's suppose you are running Debian 11. </p>
<p>You can create a folder <code>KCT</code> and <code>KCT_bin</code> in your home directory. Go into this folder and clone KCT scripts into the folder scripts.</p>
<pre class="code literal-block"><span></span><code>git clone https://github.com/kulvait/KCT_scripts.git scripts
</code></pre>


<p>Then into your .bashrc you can add the following</p>
<pre class="code literal-block"><span></span><code><span class="k">export</span> <span class="n">PATH</span><span class="o">=$</span><span class="n">PATH</span><span class="p">:</span><span class="o">~/</span><span class="n">KCT_bin</span><span class="p">::</span><span class="o">~/</span><span class="n">KCT_scripts</span>
</code></pre>


<p>Then you shall also install <a href="https://github.com/kulvait/KCT_denpy">denpy</a></p>
<pre class="code literal-block"><span></span><code>pip3 install --user git+https://github.com/kulvait/KCT_denpy.git
</code></pre>


<p>if you need to upgrade run</p>
<pre class="code literal-block"><span></span><code>pip3 install --user --upgrade git+https://github.com/kulvait/KCT_denpy.git
</code></pre>


<p>Now you have installed everything to produce the camera matrices. Optionally you might need to install KCT dentk package, that will be very useful for working with the files in <a href="../den-format.html">DEN format</a>.</p>
<p>Go to the KCT folder and clone it</p>
<pre class="code literal-block"><span></span><code>git clone https://github.com/kulvait/KCT_dentk dentk
</code></pre>


<p>Then follow the instructions in README file at https://github.com/kulvait/KCT_dentk to build the package.</p>
<h3>Python implementation</h3>
<p>When the system is set up, we can just run</p>
<pre class="code literal-block"><span></span><code>createCameraMatricesForCircularScanTrajectory.py --force --write-params-file CM.den
</code></pre>


<p>as I set all the default parameters of this script according to <a href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html">last post</a>. You can see that the den file <code>CM.den</code> and the text file <code>CM.den.params</code> were produced. Params file is not apriori needed for working with KCT but it is a good practice to know how your files were created.</p>
<p>Let's have a look to the main part of the script</p>
<pre class="code literal-block"><span></span><code><span class="n">I</span><span class="o">=</span><span class="n">ARG</span><span class="o">.</span><span class="n">source_to_isocenter</span>
<span class="n">A</span><span class="o">=</span><span class="n">ARG</span><span class="o">.</span><span class="n">source_to_detector</span>
<span class="n">M</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">ARG</span><span class="o">.</span><span class="n">projection_sizey</span><span class="p">)</span>
<span class="n">N</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">ARG</span><span class="o">.</span><span class="n">projection_sizex</span><span class="p">)</span>
<span class="n">PX</span><span class="o">=</span><span class="n">ARG</span><span class="o">.</span><span class="n">pixel_sizex</span>
<span class="n">PY</span><span class="o">=</span><span class="n">ARG</span><span class="o">.</span><span class="n">pixel_sizey</span>
<span class="n">VIEWCOUNT</span> <span class="o">=</span> <span class="n">ARG</span><span class="o">.</span><span class="n">number_of_angles</span>
<span class="n">OMEGA</span> <span class="o">=</span> <span class="n">ARG</span><span class="o">.</span><span class="n">omega_zero</span>
<span class="n">OMEGAINCREMENT</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">VIEWCOUNT</span>

<span class="c1">#Let's create specified set of projection matrices as np.array</span>
<span class="n">CameraMatrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="k">for</span> <span class="n">viewIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">VIEWCOUNT</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sourcePosition</span><span class="p">(</span><span class="n">OMEGA</span><span class="p">,</span> <span class="n">I</span><span class="p">)</span> 
    <span class="n">_A3</span><span class="o">=</span><span class="n">A3</span><span class="p">(</span><span class="n">ARG</span><span class="o">.</span><span class="n">pixel_offsetx</span><span class="p">,</span> <span class="n">ARG</span><span class="o">.</span><span class="n">pixel_offsety</span><span class="p">)</span>
    <span class="n">_A2</span><span class="o">=</span><span class="n">A2</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">_A1</span> <span class="o">=</span> <span class="n">A1</span><span class="p">(</span><span class="n">PX</span><span class="p">,</span> <span class="n">PY</span><span class="p">)</span>
    <span class="n">_E</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">_X2</span> <span class="o">=</span> <span class="n">X2</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> 
    <span class="n">_X1</span> <span class="o">=</span> <span class="n">X1</span><span class="p">(</span><span class="n">OMEGA</span><span class="p">)</span>
    <span class="n">CM</span> <span class="o">=</span> <span class="n">_A3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_A2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_A1</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_E</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_X2</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">_X1</span><span class="p">)</span>
    <span class="n">CameraMatrices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">CameraMatrices</span><span class="p">,</span> <span class="n">CM</span><span class="p">))</span>
    <span class="n">OMEGA</span> <span class="o">+=</span> <span class="n">OMEGAINCREMENT</span>

<span class="n">DEN</span><span class="o">.</span><span class="n">storeNdarrayAsDoubleDEN</span><span class="p">(</span><span class="n">ARG</span><span class="o">.</span><span class="n">outputMatrixFile</span><span class="p">,</span> <span class="n">CameraMatrices</span><span class="p">,</span> <span class="n">ARG</span><span class="o">.</span><span class="n">force</span><span class="p">)</span>
</code></pre>


<p>First we initialize the parameters.</p>
<p>Then we prepare the numpy matrices according to <a href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html">the last post</a> and finally we do the multiplication and concatenate the matrices.</p>
<p>On the last line you can see how easy is to convert <code>numpy.ndarray</code> into the DEN by one call. </p>
<p>Using the script, we produce the camera matrices we need for given trajectory setup.
To remind you the parameters let's have a look to the <code>CM.den.params</code> file</p>
<pre class="code literal-block"><span></span><code><span class="p">{</span>
  <span class="nt">"_json_message"</span><span class="p">:</span> <span class="s2">"Created using KCT script createCameraMatricesForCircularScanTrajectory.py"</span><span class="p">,</span>
  <span class="nt">"force"</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">"number_of_angles"</span><span class="p">:</span> <span class="mi">360</span><span class="p">,</span>
  <span class="nt">"omega_zero"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nt">"outputMatrixFile"</span><span class="p">:</span> <span class="s2">"CM.den"</span><span class="p">,</span>
  <span class="nt">"pixel_offsetx"</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="nt">"pixel_offsety"</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
  <span class="nt">"pixel_sizex"</span><span class="p">:</span> <span class="mf">0.616</span><span class="p">,</span>
  <span class="nt">"pixel_sizey"</span><span class="p">:</span> <span class="mf">0.616</span><span class="p">,</span>
  <span class="nt">"projection_sizex"</span><span class="p">:</span> <span class="mi">616</span><span class="p">,</span>
  <span class="nt">"projection_sizey"</span><span class="p">:</span> <span class="mi">480</span><span class="p">,</span>
  <span class="nt">"source_to_detector"</span><span class="p">:</span> <span class="mf">1198.0</span><span class="p">,</span>
  <span class="nt">"source_to_isocenter"</span><span class="p">:</span> <span class="mf">749.0</span><span class="p">,</span>
  <span class="nt">"write_params_file"</span><span class="p">:</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre>


<p>So that we can check which particular parameters were used to create our trajectory. To dig deeper, I have written <code>dentk-mathinfo</code> as part of the dentk package. We can check decompose our matrices and check properties such as source position of first few frames by running </p>
<pre class="code literal-block"><span></span><code>dentk-matinfo CM.den -f <span class="m">0</span>-5
</code></pre>


<p>with the following output</p>
<pre class="code literal-block"><span></span><code>Camera matrix from 0-th frame:
    |   -0.200     1.623     0.000   149.737|                     | 1944.805    -0.000   239.500| |    0.000     1.000     0.000|    0.000|
P = |   -0.257     0.000    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|   -0.000    -0.000    -1.000|    0.000|
    |   -0.001     0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -1.000     0.000    -0.000|  749.000|
S = [749.00, -0.00, -0.00], -Q^T u = [749.00,  0.00,  0.00].
Camera matrix from 1-th frame:
    |   -0.228     1.620     0.000   149.737|                     | 1944.805     0.000   239.500| |   -0.017     1.000    -0.000|    0.000|
P = |   -0.257    -0.004    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|   -0.000    -0.000    -1.000|    0.000|
    |   -0.001    -0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -1.000    -0.017    -0.000|  749.000|
S = [748.89, 13.07, -0.00], -Q^T u = [748.89, 13.07,  0.00].
Camera matrix from 2-th frame:
    |   -0.256     1.615     0.000   149.737|                     | 1944.805     0.000   239.500| |   -0.035     0.999    -0.000|    0.000|
P = |   -0.257    -0.009    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|   -0.000     0.000    -1.000|    0.000|
    |   -0.001    -0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -0.999    -0.035    -0.000|  749.000|
S = [748.54, 26.14, -0.00], -Q^T u = [748.54, 26.14,  0.00].
Camera matrix from 3-th frame:
    |   -0.285     1.611     0.000   149.737|                     | 1944.805     0.000   239.500| |   -0.052     0.999    -0.000|    0.000|
P = |   -0.256    -0.013    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|   -0.000     0.000    -1.000|    0.000|
    |   -0.001    -0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -0.999    -0.052    -0.000|  749.000|
S = [747.97, 39.20, -0.00], -Q^T u = [747.97, 39.20,  0.00].
Camera matrix from 4-th frame:
    |   -0.313     1.605     0.000   149.737|                     | 1944.805     0.000   239.500| |   -0.070     0.998    -0.000|   -0.000|
P = |   -0.256    -0.018    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|    0.000     0.000    -1.000|    0.000|
    |   -0.001    -0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -0.998    -0.070    -0.000|  749.000|
S = [747.18, 52.25, -0.00], -Q^T u = [747.18, 52.25,  0.00].
Camera matrix from 5-th frame:
    |   -0.341     1.600     0.000   149.737|                     | 1944.805     0.000   239.500| |   -0.087     0.996     0.000|   -0.000|
P = |   -0.256    -0.022    -1.623   192.252| = C[Q|u] =    1198.0|    0.000  1944.805   307.500|.|    0.000     0.000    -1.000|    0.000|
    |   -0.001    -0.000     0.000     0.625|                     |    0.000     0.000     1.000| |   -0.996    -0.087    -0.000|  749.000|
S = [746.15, 65.28, -0.00], -Q^T u = [746.15, 65.28,  0.00].
</code></pre>


<p>Here we can see that it was among other things able to show us source positions $S$ for the first views. This seems reasonable when looking to the image of the geometry and how we describe the trajectory. First the source is aligned with $x_1$ axis and it rotates towards $x_2$ axis.</p>
<h3>Next post</h3>
<p>In the next post we use created camera matrices, KCT cbct package and downloaded CT volume from public repository and we will show how to project the CT volumes using the FDCT trajectory, which we just created.</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../categories/using_kct_blog.html" rel="tag">using_kct_blog</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html" rel="prev" title="Working with KCT CBCT 2 Projective geometry and camera matrices to describe CT geometry">Previous post</a>
            </li>
            <li class="next">
                <a href="working-with-kct-cbct-4-first-cone-beam-ct-projection.html" rel="next" title="Working with KCT CBCT 4 First cone beam CT projection">Next post</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></article><!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:kulvait%20at%20gmail%20dot%20com">Vojtěch Kulvait</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> <br><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png">   </a><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">KCT framework wiki and blog</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Vojtěch Kulvait</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. <br>
KCT framework itself is licensed under the terms of GNU GPL3 license. <br>
Any data provided on this site or within the KCT framework may be subject to different licensing arrangements.

            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
