<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#
" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="KCT framework documentation">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>KCT framework</title>
<link href="../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="en" href="../rss.xml">
<link rel="canonical" href="https://kulvait.github.io/KCT_doc/posts/">
<!--[if lt IE 9]><script src="../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>

<!-- Menubar -->

<nav class="navbar navbar-expand-md static-top mb-4
navbar-dark
bg-dark
"><div class="container">
<!-- This keeps the margins nice -->
        <a class="navbar-brand" href="../">

            <span id="blog-title">KCT framework</span>
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#bs-navbar" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="bs-navbar">
            <ul class="navbar-nav mr-auto">
<li class="nav-item">
<a href="../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../categories/" class="nav-link">Tags</a>
                </li>
<li class="nav-item">
<a href="../rss.xml" class="nav-link">RSS feed</a>

                
            </li>
</ul>
<ul class="navbar-nav navbar-right"></ul>
</div>
<!-- /.navbar-collapse -->
    </div>
<!-- /.container -->
</nav><!-- End of Menubar --><div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        

    


    
<div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html" class="u-url">Working with KCT CBCT 2 Projective geometry and camera matrices to describe CT geometry</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Vojtěch Kulvait
            </span></p>
            <p class="dateline">
            <a href="working-with-kct-cbct-2-projective-geometry-and-camera-matrices-to-describe-ct-geometry.html" rel="bookmark">
            <time class="published dt-published" datetime="2021-09-14T12:05:50+02:00" itemprop="datePublished" title="2021-09-14 12:05">2021-09-14 12:05</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>Before we define particular geometry corresponding to the flat panel detector CT trajectory, we need to know some theory about projective geometry and camera matrices. This will be the content of this post.</p>
<h3>CT projections geometry</h3>
<p>In the computer tomography, we project 3D object in $ \mathbb{R}^3 $ to the projector grid. Let's say it is a two dimensional grid that consist of rectangular pixels. Natural space of the detector when considering discretization is $ \mathbb{R}^2 $ as the projections are 2D images. The process of the projection is analogous to the pinhole camera model that projects the scene onto the 2D plane. And therefore projective geometry is a good tool to study this correspondence.</p>
<h3>Projective geometry</h3>
<p>Projective space is a structure on top of an Vector space $\mathbf{V}$ that is not a vector space itself. For an introduction into the projective geometry, see <a href="http://math.unife.it/insegnamenti/geometria-differenziale/materiale-didattico/projective.pdf">class notes of Nigel Hitchin</a>. I will follow some of its definitions</p>
<blockquote>
<p>The projective space $\mathcal{P}(\mathbf{V})$ of a vector space $\mathbf{V}$ is a set of one dimensional subspaces of $\mathbf{V}$. The dimension of $\mathcal{P}(\mathbf{V})$ is $dim(\mathbf{V}) - 1$. Projective space of dimension $1$ is called projective line and projective space of dimension $2$ is called projective plane.</p>
</blockquote>
<p>It is interesting to see in this definitions, that when we take the space $\mathbb{R}^3$, where the source is placed in its origin. We constract "a set of one dimensional subspaces of $\mathbb{R}^3$", which are all the lines through the origin representing all the rays going from the source. The number of lines with this characteristic is (almost) the same as the number of the points on the unit half sphere. We however will be projecting this structure onto the planar detector.</p>
<h3>Construction of camera matrices</h3>
<p>Let's have the following FDCT setup</p>
<p><img src="../images/CTSchemeCVP.png"></p>
<p>The configuration is uniquely determined by the position of the source $\vec{s} = (s_0, s_1, s_2)$ in the word coordinates, position of the principal point $\vec{p} = (p_0, p_1, p_2)$ that is a point on the detector such that the line |\vec{s} \vec{p}| is orthogonal to the detector surface. The ray defined by that line is called the principal ray. Apart from that we have to define position of the zero on the detector, size of the detector pixels. All this information can be embedded in the camera matrix.</p>
<p>Size of the detector by means of the </p>
<p>Let's suppose we have a source position $\vec{s} = (s_0, s_1, s_2)$ and that the $z$ axis of the geometry is the axis of the rotation. We further assume that principal ray hits the detector in its center and at the same time principal ray is orthogonal to $z$ axis. Lets $A$ be the distance from the source to detector $(P_0, P_1)$ be the sizes of the detector pixels in the units of the coordinates $(x,y,z)$ that are isometric. There is $M \times N$ detector pixels. Its axes will be $\chi_1$ and $\chi_2$, where $\chi_1$ will be orthogonal to $z$ and $\chi_2$ will be parrallel to $z$ with oposite orientation. Orientation of the world coordinates will be as it is described <a href="https://www.slicer.org/w/img_auth.php/2/22/Coordinate_sytems.png">here</a>. By angle $\omega$ we describe polar angle that principal ray from the detector to source has with $xy$ axes.</p>
<p>From this information we construct camera matrix for given projection setup. First we transform $(x,y,z)$ to the $(x' , y' , z' )$ that is centered in the source position. First as on the projections $\chi_2$ coordinate is usually encoded going from the top to bottom we would like to identify positive direction of $\chi_2$ with negative direction of $z$ by means of $z'=-z$. We rotate the geometry in the way that $y'$ will be in the direction of principal ray and $x'$ will be colinear with $\chi_1$ on the detector. So we use the following projective element 
$$
\mathbb{X}_1 =
\begin{pmatrix} 
\sin{\alpha}&amp; -\cos{\alpha} &amp;0 &amp;0 \\
\cos{\alpha}&amp; \sin{\alpha}&amp;0 &amp;0 \\ 
0&amp;0&amp;-1&amp;0 \\
0&amp;0&amp;0&amp;1 
\end{pmatrix},
$$
where $\alpha = \atantwo{(-s_1, -s_0)}$.</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="working-with-kct-cbct-1-converting-dicom-volume-to-den-volume-using-dicom-data-from-public-repository.html" class="u-url">Working with KCT CBCT 1 Converting DICOM volume to DEN volume</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Vojtěch Kulvait
            </span></p>
            <p class="dateline">
            <a href="working-with-kct-cbct-1-converting-dicom-volume-to-den-volume-using-dicom-data-from-public-repository.html" rel="bookmark">
            <time class="published dt-published" datetime="2021-09-13T12:44:40+02:00" itemprop="datePublished" title="2021-09-13 12:44">2021-09-13 12:44</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>In this series of blog posts, I will describe how to work with the KCT framework from the first steps of importing data to the more advanced topics as a running reconstruction. </p>
<p>In the post today, I explain how to import files in DICOM into the DEN format that is used within the framework. I use the data from the public repository.</p>
<h3>Example dataset</h3>
<p>I have choosen a publicly available dataset from <a href="https://public.cancerimagingarchive.net/">The Cancer Imaging Archive</a> containing a brain CT scan, ID TCGA-19-1787. To download this dataset I followed the procedure described on <a href="https://wiki.cancerimagingarchive.net/display/NBIA/Downloading+TCIA+Images">The Cancer Imaging Archive page</a>. It is needed to instal their application NBIA Data Retriever and provide it with the information in the <code>manifest-1631446347856.tcia</code> file, which must contain the following</p>
<pre class="code literal-block"><span></span><code><span class="n">downloadServerUrl</span><span class="o">=</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">public</span><span class="o">.</span><span class="n">cancerimagingarchive</span><span class="o">.</span><span class="n">net</span><span class="o">/</span><span class="n">nbia</span><span class="o">-</span><span class="n">download</span><span class="o">/</span><span class="n">servlet</span><span class="o">/</span><span class="n">DownloadServlet</span>
<span class="n">includeAnnotation</span><span class="o">=</span><span class="bp">true</span>
<span class="n">noOfrRetry</span><span class="o">=</span><span class="mi">4</span>
<span class="n">databasketId</span><span class="o">=</span><span class="n">manifest</span><span class="o">-</span><span class="mf">1631446347856.</span><span class="n">tcia</span>
<span class="n">manifestVersion</span><span class="o">=</span><span class="mf">3.0</span>
<span class="n">ListOfSeriesToDownload</span><span class="o">=</span>
<span class="mf">1.3</span><span class="o">.</span><span class="mf">6.1</span><span class="o">.</span><span class="mf">4.1</span><span class="o">.</span><span class="mf">14519.5</span><span class="o">.</span><span class="mf">2.1</span><span class="o">.</span><span class="mf">5826.4001</span><span class="o">.</span><span class="mi">312669389023517091391958251391</span>
</code></pre>


<p>Example dataset is published under the terms of <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a> and the <a href="../license-tcga-gbm.html">following terms</a>. This licencing apply to any user even the user of the derived data, which I publish here in scope of this demonstration in <a href="https://github.com/kulvait/KCT_den_file_opener/releases/download/v1.1.1/ExampleVolumeKCT_TCGA-19-1787.tar.xf">Example Volume TCGA-19-1787</a>.</p>
<p>When we unpack the data of example volume, we see that dicom files with the suffix dcm are in the directory <code>TCGA-19-1787/04-20-2002-NA-NR CT HEAD W CE-97133/2.000000-Head Vol.  1.5  H40s ST-51391</code>. For simplicity I rename this directory just to DICOM and remove parent subdirectories. 
From the DICOM headers we can see that it is a scan on SIEMENS Sensation Cardiac 64 CT machine. It contains $124$ slices with the thickness of $1.5$mm of the dimension $512 \times 512$, the voxel sizes are ($0.64453125$mm, $0.64453125$mm, $1.5$mm).</p>
<h3>Conversion of DICOM series to DEN format</h3>
<p>For the purpose of this example, we have to transform the DICOM dataset into the <a href="../den-format.html">DEN format</a>, which is used by KCT framework. We do it using <a href="https://github.com/kulvait/KCT_denpy">KCT_denpy package</a>. This package allow us to convert between the representations of the volume data as numpy.ndarray, DEN file or DICOM series. Internally it uses the package pydicom to read DICOM data.</p>
<p>For the conversion, I have created a simple script <code>[DICOMTODEN.py](https://github.com/kulvait/KCT_scripts/blob/master/DICOMTODEN.py)</code>. The command to convert the data to the DEN format will then be</p>
<pre class="code literal-block"><span></span><code>DICOMTODEN.py --force --dicom-file-suffix <span class="s2">"dcm"</span> DICOM DEN_HU
</code></pre>


<p>After you run this command, the new directory <code>DEN_HU</code> will be created, which contains file <code>Series_00.den</code>. This is a converted DICOM file into the DEN format. To vizualize the volume can be used <a href="https://github.com/kulvait/KCT_den_file_opener/releases/download/v1.1.1/KCT_Den_File_Opener-1.1.1.jar">KCT Den file opener</a>, a plugin of <a href="https://imagej.nih.gov/ij/">ImageJ</a> viewer that works also with <a href="https://imagej.net/software/fiji/">Fiji</a>. It is sufficient to put a file KCT_Den_File_Opener-1.1.1.jar into the .imagej/plugins configuration directory of ImageJ. Then simpy select <code>File-&gt;Open DEN ..</code> and navigate to <code>Series_00.den</code>.</p>
<p>You can notice that the values are integers starting from $-1024$ in the areas of the air up to values greater than $1000$ in the dense bone areas. These are in (Hounsfield units)[https://en.wikipedia.org/wiki/Hounsfield_scale], which are good for the physicans to compare tissue contrasts in a convenient scale, but they do not represent raw attenuation values. To do a projection of the data using KCT or reconstruction of these projections, we need raw attenuation values.</p>
<p>Conversion between Hounsfield units and raw attenuation values is possible using (KCT dentk toolkit)[https://github.com/kulvait/KCT_dentk]. Install the tool <code>dentk-fromhu</code> to your path and then the conversion can be done either by calling</p>
<pre class="code literal-block"><span></span><code>dentk-fromhu Series_00.den Series_00.raw
</code></pre>


<p>or using the script <code>DICOMTODEN.py</code> to internally call <code>dentk-fromhu</code> and to produce raw attenuations</p>
<pre class="code literal-block"><span></span><code>DICOMTODEN.py --force --dicom-file-suffix <span class="s2">"dcm"</span> --convert-hu-to-raw --base2 DICOM DEN_RAW
</code></pre>


<p>There are two caveats. First for the conversion is important the attenuation value of the water, which in Hounsfield units is exactly $0$. By default the conversion will be performed in the same way as with the setting <code>--water-value 0.027</code>. If you know the exact attenuation value of the water for given scanner, feel free to change it.</p>
<p>Second there is a problem that in <a href="https://en.wikipedia.org/wiki/Hounsfield_scale">wiki article about Hounsfield units</a> as well as in virtually every CT textbook, you can find that the minimum Hounsfield unit is 1000. DICOM data from SIEMENS scanners tend to have this minimum value $-1024$. It is due to the better data alignment with uint16 or uint32 representation of offsetted Hounsfield units. Standard conversion formula would however produce negative attenuation values. To correct for this undesired behavior we have to add <code>--base2</code> as a parameter either to <code>DICOMTODEN.py</code> or <code>dentk-fromhu</code> program.</p>
<h3>Vizualizing DEN volume of raw attenuation values derived from DICOM series</h3>
<p>When you did everything correct, in the directory <code>DEN_RAW</code> is the file <code>Series_00.den</code>, which represent raw attenuation values derived from given DICOM series. You can also download <a href="https://github.com/kulvait/KCT_den_file_opener/releases/download/v1.1.1/ExampleVolumeKCT_TCGA-19-1787.tar.xf">Example Volume TCGA-19-1787</a>, which contain also the converted DEN volume.</p>
<p>When vizualizing in ImageJ, you can select an area of the soft tissue and press ALT+CTRL+C. Then you can adjust the contrast. </p>
<p>Investigating the volume in more detail from the perspective of data alignment it is apparent that the convention described on the picture <a href="https://www.slicer.org/wiki/File:Coordinate_sytems.png">CT coordinates, image from the project slicer</a> is observed. So that z axis is the axis of the rotation. Y axis goes from the top (above scanned subject) to bottom (under scanned object). Note, that ImageJ places the (0,0) top left and the positive direction of the Y axis is also top to bottom so that the axial image is vizualized in a natural orientation.  </p>
<h3>Working with KCT CBCT 2</h3>
<p>In the next post, I will explain what are the conventions for the projection geometry and how to describe the geometric setting of the flat detector CT. We define an example setup of a virtual flat detector CT machine when scannin the volume created in this post. We then use KCT framework to project the volume and create projections.</p>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="kct-framework.html" class="u-url">KCT framework</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Vojtěch Kulvait
            </span></p>
            <p class="dateline">
            <a href="kct-framework.html" rel="bookmark">
            <time class="published dt-published" datetime="2021-09-13T12:04:57+02:00" itemprop="datePublished" title="2021-09-13 12:04">2021-09-13 12:04</time></a>
            </p>
        </div>
    </header><div class="e-content entry-content">
    <div>
<p>KCT framework is a set of sotware tools to process computer tomography data. It was founded by Vojtěch Kulvait to support his PostDoc research at University of Magdeburg 2018-2021. Work is focused on processing, manipulating and reconstructing the data from the C-Arm CT systems with a flat panel detector, FDCT. It consists of multiple packages described below.</p>
<p>These tools are tested and the compatibility will be maintained towards Debian 11 bullseye with AMD64 CPU. After the compilation, command line programs are built, which use command line parser (CLI11)[https://github.com/CLIUtils/CLI11] to specify inputs, outputs and parameters. BASH scripting is a common practice to put these programs into the CT data processing functional pipelines. </p>
<h3><a href="https://github.com/kulvait/KCT_cbct">KCT cbct</a></h3>
<p>Contains C++ and OpenCL implementation of various methods for algebraic CT reconstruction.</p>
<h3><a href="https://github.com/kulvait/KCT_dentk">KCT dentk</a></h3>
<p>It contains tools written in C++ to process files in the <a href="DEN-format">DEN format</a> to store 3D volume data. Format is derived and compatible with the format reffered as Dennerlein or DEN format.</p>
<h3><a href="https://github.com/kulvait/KCT_denpy">KCT denpy</a></h3>
<p>Python package to manipulate filues in DEN format. It uses pydicom package to read DICOM data. Files in formats is possible to convert to numpy.ndarray. By this mechanism is possible to convert series of DICOM files into the DEN files that are used within the framework. </p>
<h3><a href="https://github.com/kulvait/KCT_ctiol">KCT ctiol</a></h3>
<p>C++ library with input output routines for asynchronous thread safe reading/writing CT data. This library is typically a dependency/submodule of other C++ tools in KCT.</p>
<h3><a href="https://github.com/kulvait/KCT_ctmal">KCT ctmal</a></h3>
<p>C++ library with mathematic/algebraic algorithms for supporting CT data manipulation. This library is typically a dependency/submodule of other C++ tools in KCT.</p>
</div>
    </div>
    </article>
</div>





        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2021         <a href="mailto:kulvait%20at%20gmail%20dot%20com">Vojtěch Kulvait</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a> <br><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png">   </a><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">KCT framework wiki and blog</span> by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Vojtěch Kulvait</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License</a>. <br>
KCT framework itself is licensed under the terms of GNU GPL3 license. <br>
Any data provided on this site or within the KCT framework may be subject to different licensing arrangements.

            
            
        </footer>
</div>
</div>


        <script src="../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
